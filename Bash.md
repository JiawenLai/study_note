#### 一、Bash与Shell

##### 1. shell

- 能够操作应用程序的接口的壳程序；
- /bin/bash 是 linux 默认的 shell；

##### 2. Bash Shell

- 命令编修能力：~/.bash_history 记录前一次登陆以前所执行过的指令， 至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 .bash_history 当中；

- 命令与文件补全功能：[Tab]按键；

- 命令别名设置功能

  ```bash
  alias # 显示所有命令别名
  alias lm=‘ls -al’ # 设置命令别名
  ```

- 工作控制、前景背景控制；

- 程序化脚本：shell script；

- 万用字符；

##### 3. 查询是否为Bash shell内置命令

```bash
type [-tpa] name
```

```
不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
-t：当加入-t参数时，type 会将 name 以下面这些字眼显示出他的意义：
      file：表示为外部指令；
      alias：表示该指令为命令别名所设置的名称；
      builtin：表示该指令为 bash 内置的指令功能；
-p：如果后面接的 name 为外部指令时，才会显示完整文件名；
-a：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias；
```

##### 4. 指令的下达与快速编辑按钮

- 使用 \ + [Enter] 可以跳行
- [ctrl] + u 从光标处向前删除指令串， [ctrl] + k 向后删除指令串。
- [ctrl] + a 让光标移动到整个指令串的最前面，[ctrl] + e 移动到最后面。

#### 二、Shell的变量功能

##### 1. 变量的取用、删除、设置

- 变量的取用

  ```bash
  echo $变量名 或 ${变量名}
  ```

- 变量的删除

  ```bash
  unset $变量名
  ```

- 变量的设置

  ```bash
  变量名=变量内容 # 设置一个变量
  ```

  - 等号两边不能直接接空白字符；
  - 变量名称只能是英文字母与数字，开头字符不能是数字；
  - 变量内容有空白字符可以使用单引号与双引号，双引号内的特殊字符保持原有特性，单引号内的特殊字符仅为一个字符；
  - 可以使用跳脱字符 \ 将特殊符号（[Enter]、$、\，空白字符等）变成一般字符；
  - 使用反单引号``或者$(指令)可以在一串指令中执行另一条指令；
  - 若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容；
  - 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量；
  - 通常大写字符为系统默认变量，自行设置的变量使用小写字符；

##### 2. 环境变量

- 环境变量的内容

  - HOME：代表使用者的主文件夹；
  - SHELL：环境使用的SHELL是哪支程序；
  - HISTSIZE：记录历史命令的数量；
  - MALL：系统去读取邮件信箱文件；
  - PATH：可执行文件的搜寻路径；
  - LANG：语系数据；
  - RANDOM：产生一个随机数（0～32768）；

- 观察所有变量：set

  - PS1：提示字符的设置；
  - $：目前这个SHELL的线程代号（PID）；
  - ?：关于上个执行指令的回传值，成功执行回传0；
  - OSTYPE、HOSTTYPE、MACHTYPE：主机硬件与核心的等级；

- 自定变量转环境变量：export

  ```bash
  export 变量名称 #没有接环境变量就显示所有的环境变量
  ```

- 语系变量

  ```bash
  locale -a #显示支持的所有语系
  ```

  - 设置LANG和LC_ALL时，其他语系变量就会被这两个取代；
  - /etc/locale.conf中存放系统默认语系；

- 变量的有效范围：环境变量可以被子程序所引用，自定变量不会存在子程序中；

##### 3. 变量键盘读取、阵列与宣告

- read：读取来自键盘输入的变量；

  ```bash
  read [-pt] variable
  ```

  ```bash
  -p：后面可以接提示字符;
  -t：后面可以接等待的秒数;
  ```

- declare/typeset：宣告变量类型；

  ```bash
  declare [-aixr] variable #不接任何参数显示所有变量
  ```

  ```bash
  -a：将后面名为 variable 的变量定义成为阵列 （array） 类型；
  -i：将后面名为 variable 的变量定义成为整数数字 （integer） 类型；
  -x：用法与 export 一样，就是将后面的 variable 变成环境变量；
  -r：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset;
  -p：单独列出变量类型；
  ```

  - 变量类型默认为字串；
  - bash环境中的数值运算默认最多仅能达到整数形态；

- 阵列变量类型

  ```bash
  a[1]="one" 
  a[2]="two" #设置
  echo $a #读取 one two
  ```

##### 4. 与文件系统及程序

```bash
ulimit [-SHacdfltu] [配额]
```

```bash
-H：hard limit ，严格的设置，必定不能超过这个设置的数值；
-S：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。在设置上，通常 soft 会比 hard 小；
-a：后面不接任何选项与参数，可列出所有的限制额度；
-c：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量；
-f：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes；
-d：程序可使用的最大断裂内存（segment）容量；
-l：可用于锁定 （lock） 的内存量；
-t：可使用的最大 CPU 时间 （单位为秒）；
-u：单一使用者可以使用的最大程序（process）数量；
```

##### 5. 变量内容的删除、取代与替换

- 变量内容的删除

  ```bash
  ${变量#关键字} #若变量内容从头开始的数据符合“关键字”，则将符合的最短数据删除
  ${变量##关键字} #若变量内容从头开始的数据符合“关键字”，则将符合的最长数据删除
  ```
  
  ```bash
  ${变量%关键字} #若变量内容从尾向前的数据符合“关键字”，则将符合的最短数据删除
  ${变量%%关键字} #若变量内容从尾向前的数据符合“关键字”，则将符合的最长数据删除
  ```
  
- 变量内容的取代

  ```bash
  ${变量/旧字串/新字串} #若变量内容符合“旧字串”则“第一个旧字串会被新字串取代”
  ${变量//旧字串/新字串}	#若变量内容符合“旧字串”则“全部的旧字串会被新字串取代”
  ```

- 变量的测试

  | 变量设置方式     | str 没有设置       | str 为空字串       | str 已设置非为空字串 |
  | ---------------- | ------------------ | ------------------ | -------------------- |
  | var=${str-expr}  | var=expr           | var=               | var=$str             |
  | var=${str:-expr} | var=expr           | var=expr           | var=$str             |
  | var=${str+expr}  | var=               | var=expr           | var=expr             |
  | var=${str:+expr} | var=               | var=               | var=expr             |
  | var=${str=expr}  | str=expr var=expr  | str 不变 var=      | str 不变 var=$str    |
  | var=${str:=expr} | str=expr var=expr  | str=expr var=expr  | str 不变 var=$str    |
  | var=${str?expr}  | expr 输出至 stderr | var=               | var=$str             |
  | var=${str:?expr} | expr 输出至 stderr | expr 输出至 stderr | var=$str             |


#### 三、命令别名与历史命令

##### 1. 命令别名设置

- 查看命令别名

  ```bash
  alias
  ```

- 设置命令别名

  ```bash
  alias 别名=指令
  ```

- 取消命令别名

  ```bash
  unalias 别名
  ```

##### 2. 历史命令

```bash
history [n]
history [-c]
history [-raw] histfiles
```

```bash
n ：数字，意思是“要列出最近的 n 笔命令列表”的意思；
-c：将目前的 shell 中的所有 history 内容全部消除；
-a：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ，则默认写入 ~/.bash_history；
-r：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；
-w：将目前的 history 记忆内容写入 histfiles 中；
```

```bash
!number #执行第几笔指令的意思
!command #由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行
!! #执行上一个指令
```

#### 四、Bash Shell的操作环境

##### 1. 路径与指令搜寻顺序

- 以相对/绝对路径执行指令，例如“ /bin/ls ”或“ ./ls ”；
- 由 alias 找到该指令来执行；
- 由 bash 内置的 （builtin） 指令来执行；
- 通过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。

##### 2. bash的进站与欢迎讯息

- 本地登录：/etc/issue；
- 远端登录：/etc/issue.net；
- 提示信息：/etc/motd；

##### 3. bash的环境配置文件

- /etc/profile（只有login shell读）：利用使用者的识别码 （UID） 来决定很多重要的变量数据，变量主要有PATH、MAIL、USER、HOSTNAME、HISTSIZE、umask；调用外部的设置数据；

- ~/.bash_profile（只有login shell读）：使用者的个人配置文件，并会调用~/.bashrc的设置内容；

- ~/.bashrc（non-login shell会读）：会调用/etc/bashrc文件；

- source：读入环境配置文件的指令

  ```bash
  source 配置文件文件名
  ```

- /etc/man_db.conf：规定了下达 man 的时候，该去哪里查看数据的路径设置；

- ~/.bash_history：记录历史命令；

- ~/.bash_logout：规定登出 bash 后，系统做完什么动作后才离开；

##### 4. 终端机的环境设置

- stty 可以设置终端机的输入按键代表意义；
- set 可以设置整个指令输出/输入的环境；

##### 5. 万用字符与特殊符号

字符：

- *：代表“ 0 个到无穷多个”任意字符；
- ?：代表“一定有一个”任意字符；
- []：代表“一定有一个在括号内”的字符（非任意字符）；
- [-]：若有减号在中括号内时，代表“在编码顺序内的所有字符”；
- [^]：若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”；

符号：

- #：注解符号，这个最常被使用在 script 当中，视为说明！在后的数据均不执行；
- \：跳脱符号，将“特殊字符或万用字符”还原成一般字符；
- |：管线 （pipe），分隔两个管线命令的界定（后两节介绍）；
- ；：连续指令下达分隔符号，连续性命令的界定；
- ~：使用者的主文件；
- $：取用变量前置字符，亦即是变量之前需要加的变量取代值；
- &：工作控制 （job control），将指令变成背景下工作；
- ！：逻辑运算非；
- /：目录符号，路径分隔的符号；
- ' '：不具有变量置换的功能 （$ 变为纯文本）；
- " "：具有变量置换的功能！ （$ 可保留相关功能）；
- ``：中间为可以先执行的指令，亦可使用 $（ ）；
- ( )：在中间为子 shell 的起始与结束；
- { }：在中间为命令区块的组合；
- ">"、">>"：数据流重导向，输出导向；
- "<"、"<<"：数据流重导向，输入导向；

#### 五、数据流重导向

##### 1. 相关概念

- 标准输入standard input：将原本需要由键盘输入的数据，改由文件内容来取代，代码为 0 ，使用 < 或 << （控制结束的输入字符）；

- 标准输出standard output：指令执行所回传的正确的讯息，代码为 1 ，使用 > （覆盖）或 >> （累加）；
- 标准错误输出standard error output：指令执行失败后，所回传的错误讯息，代码为 2 ，使用 2> （覆盖）或 2>> （累加）；
- 垃圾桶黑洞设备/dev/null：可以吃掉任何导向这个设备的信息；

##### 2. 命令执行的判断依据

- 在指令与指令之间使用；分隔开，可以连续执行多条指令，指令与指令之间不考虑相关性；
- $?：指令回传值，若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值；
- 命令1 && 命令2：命令1正确执行才会执行命令2；
- 命令1 || 命令2：命令1执行错误才会执行命令2； 

#### 六、管线命令

- 管线命令仅会处理 standard output，对于 standard error output 会予以忽略
- 管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。

##### 1. 撷取命令

- cut：主要的用途在于将同一行里面的数据进行分解；

  ```bash
  cut -d'分隔字符' -f fields
  cut -c 字符区间
  
  选项与参数：
  -d  ：后面接分隔字符。与 -f 一起使用；
  -f  ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；
  -c  ：以字符 （characters） 的单位取出固定字符区间；
  ```

- grep：可以解析一行文字，取得关键字，若该行有存在关键字，就会整行列出来；

  ```bash
  grep [-acinv] [--color=auto] '搜寻字串' filename
  
  选项与参数：
  -a：将 binary 文件以 text 文件的方式搜寻数据；
  -c：计算找到 '搜寻字串' 的次数；
  -i：忽略大小写的不同，所以大小写视为相同；
  -n：顺便输出行号；
  -v：反向选择，亦即显示出没有 '搜寻字串' 内容的那一行；
  --color=auto：可以将找到的关键字部分加上颜色的显示喔；
  ```

##### 2. 排序命令

- sort：排序；

  ```bash
  sort [-fbMnrtuk] [file or stdin]
   
  选项与参数：
  -f：忽略大小写的差异，例如 A 与 a 视为编码相同；
  -b：忽略最前面的空白字符部分；
  -M：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
  -n：使用“纯数字”进行排序（默认是以文字体态来排序的）；
  -r：反向排序；
  -u：就是 uniq ，相同的数据中，仅出现一行代表；
  -t：分隔符号，默认是用 [tab] 键来分隔；
  -k：以那个区间 （field） 来进行排序的意思
  ```

- uniq：想要将重复的数据仅列出一个显示；

  ```bash
  uniq [-ic]
  
  选项与参数：
  -i：忽略大小写字符的不同；
  -c：进行计数
  ```

- wc：计算输出的讯息的整体数据；

  ```bash
  wc [-lwm]
  
  选项与参数：
  -l：仅列出行；
  -w：仅列出多少字（英文单字）；
  -m：多少字符；
  ```

##### 3. 双向重导向

- tee：同时将数据流分送到文件去与屏幕 ；

  ```bash
  tee [-a] file
  
  选项与参数：
  -a：以累加 （append） 的方式，将数据加入 file 当中！
  ```

##### 4. 字符转换命令

- tr：可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换；

  ```bash
  tr [-ds] SET1 ...
  
  选项与参数：
  -d：删除讯息当中的 SET1 这个字串；
  -s：取代掉重复的字符；
  ```

- col：将 [tab] 按键取代成为空白键；

  ```bash
  col [-xb]
  
  选项与参数：
  -x：将 tab 键转换成对等的空白键
  ```

- join：两个文件当中，有相同数据的那一行，才将他加在一起；

  ```bash
  join [-ti12] file1 file2
  
  选项与参数：
  -t：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个；
  -i：忽略大小写的差异；
  -1：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；
  -2：代表“第二个文件要用那个字段来分析”的意思。
  ```

- paste

